<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ad hoc counting for Bastian</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Ad hoc counting for Bastian</h1>

<p>2015-05-18 15:58:27</p>

<p><br/>
<br/></p>

<h2>Introduction</h2>

<p>This file is not part of our Eurocan microRNA project, but special made for Bastian. </p>

<p><br/>
<br/></p>

<h2>Input data</h2>

<p>Setting some dependencies</p>

<pre><code class="r">library(limma)
library(xtable)

set.seed(100)
if(!exists(&quot;inputisread&quot;))
    source(&quot;read_input.r&quot;)
</code></pre>

<p><br/>
<br/></p>

<p>Reading Bastian´s list of microRNAs with MIMAT and status.</p>

<pre><code class="r">    curatedfn = &quot;curated_microRNA_MIMAT.csv&quot;
  orgcuratedtab  = read.table(paste(&quot;not_in_github&quot;, &quot;/&quot;, curatedfn, sep=&quot;&quot;), sep=&quot;\t&quot;, 
                                                 header=TRUE, stringsAsFactors=FALSE, fill=TRUE,
                                     strip.white=TRUE, comment.char =&quot;&quot;)
    orgcuratedtab$miRNA = paste(&quot;hsa-&quot;, orgcuratedtab$miRNA, sep=&quot;&quot;)

    curatedtab = orgcuratedtab[,c(1,2, 4, 3)]
    names(curatedtab)[3]= &quot;MIMAT&quot;
    names(curatedtab)[4]= &quot;MI&quot;

    curatedtab = rbind(curatedtab, 
                                         #setNames( orgcuratedtab[,c(1,2,4)], names(curatedtab)),
                                         setNames( orgcuratedtab[,c(1,2,5,3)], names(curatedtab)),
                                         setNames( orgcuratedtab[,c(1,2,6,3)], names(curatedtab)) )
    curatedtab = curatedtab[curatedtab$MIMAT != &quot;&quot;, ]

    table(orgcuratedtab$status)
</code></pre>

<pre><code>## 
##   purple rejected    white   yellow 
##      302      969      484        4
</code></pre>

<p>The above table is the count of the different types from Bastian´s file.</p>

<p><br/>
<br/></p>

<h2>microRNA in Caldas et al.</h2>

<p>The array they used was custom made with a lot of <em>CRI</em> probes. In total it has <strong>8150</strong> unique microRNA IDs. The breakdown based on type (as deduced by the 3 first letters:)</p>

<pre><code class="r">table(substring(ucam_genes, 1, 3))
</code></pre>

<pre><code>## 
##  bkv  Bla  CRI  dmr  ebv  hbv  hcm  hiv  hsa  hsv  hur  jcv  ksh  miR  mr_ 
##    2    1 6902    6   44    3   17    4 1083   48    5    2   24    1    1 
##  NC1  NC2  Neg 
##    2    4    1
</code></pre>

<p><br/>
<br/></p>

<p>Mapping names from the microarray to Bastians list via MIMATID.</p>

<pre><code class="r">comb = data.frame(uniqueID=union(unfilteredUCAMMIMAT, unfilteredAHUSMIMAT), stringsAsFactors=FALSE)
comb$lookupID = unlist(lapply(comb$uniqueID, FUN=function(x)strsplit(x, &quot;_&quot;)[[1]][1]))
comb$MI = curatedtab[match(comb$lookupID, curatedtab$MIMAT), &quot;MI&quot;]
comb$status = curatedtab[match(comb$lookupID, curatedtab$MIMAT), &quot;status&quot;]
comb$name = curatedtab[match(comb$lookupID, curatedtab$MIMAT), &quot;miRNA&quot;]
comb$AHUS = &quot;notonarray&quot;
comb$AHUS[(comb$uniqueID %in% unfilteredAHUSMIMAT)]=&quot;notexpressed&quot;
comb$AHUS[(comb$uniqueID %in% filteredAHUSMIMAT)]=&quot;expressed&quot;
comb$UCAM = &quot;notonarray&quot;
comb$UCAM[(comb$uniqueID %in% unfilteredUCAMMIMAT)]=&quot;notexpressed&quot;
comb$UCAM[(comb$uniqueID %in% filteredUCAMMIMAT)]=&quot;expressed&quot;
comb = comb[!is.na(comb$status),]
#comb[1:10,]
#table(comb[comb$status==&quot;purple&quot;, c(&quot;AHUS&quot;, &quot;UCAM&quot;)])


tab = rbind(nonexpressed=table(comb$status[comb$UCAM==&quot;notexpressed&quot;]),
                        expressed=table(comb$status[comb$UCAM==&quot;expressed&quot;]))

tab = cbind(tab, sum=rowSums(tab))
perctab = round(tab/rowSums(tab) * 100 * 2, 0)
x = paste(tab,paste(&quot;(&quot;, perctab, &quot;%)&quot;, sep=&quot;&quot;), sep=&quot; &quot;)
nicetab = matrix(x, nrow=nrow(perctab), ncol=ncol(perctab), dimnames=dimnames(perctab))

print( xtable(nicetab, caption=&quot;&quot;, digits=0), 
      comment = FALSE,
      type = &quot;html&quot;,
      html.table.attributes=&quot;CELLPADDING=5&quot;,
      include.rownames = TRUE)
</code></pre>

<table CELLPADDING=5>
<caption align="bottom">  </caption>
<tr> <th>  </th> <th> purple </th> <th> rejected </th> <th> white </th> <th> yellow </th> <th> sum </th>  </tr>
  <tr> <td align="right"> nonexpressed </td> <td> 81 (18%) </td> <td> 174 (39%) </td> <td> 190 (43%) </td> <td> 1 (0%) </td> <td> 446 (100%) </td> </tr>
  <tr> <td align="right"> expressed </td> <td> 40 (7%) </td> <td> 106 (18%) </td> <td> 439 (75%) </td> <td> 2 (0%) </td> <td> 587 (100%) </td> </tr>
   </table>

<p>The above table might count a microRNA two times. Several different microRNA names from the array might end up link to the same microRNA listed in Bastian´s file. Both arms of the miroRNA can be printed, and sometimes one is expressed, while the other is not. This is difficult to count in an easy understandable way. If I counted unique microRNA´s, some will be both expressed and non-expressed.
<br/>
<br/>
The above numbers differed from what we got from the combined data set, especially for the purple type. Therefore, I do the same table for the AHUS only data:</p>

<pre><code class="r">tab = rbind(nonexpressed=table(comb$status[comb$AHUS==&quot;notexpressed&quot;]),
                        expressed=table(comb$status[comb$AHUS==&quot;expressed&quot;]))
tab = cbind(tab, sum=rowSums(tab))
perctab = round(tab/rowSums(tab) * 100 * 2, 0)
x = paste(tab,paste(&quot;(&quot;, perctab, &quot;%)&quot;, sep=&quot;&quot;), sep=&quot; &quot;)
nicetab = matrix(x, nrow=nrow(perctab), ncol=ncol(perctab), dimnames=dimnames(perctab))

print( xtable(nicetab, caption=&quot;&quot;, digits=0), 
      comment = FALSE,
      type = &quot;html&quot;,
      html.table.attributes=&quot;CELLPADDING=5&quot;,
      include.rownames = TRUE)
</code></pre>

<table CELLPADDING=5>
<caption align="bottom">  </caption>
<tr> <th>  </th> <th> purple </th> <th> rejected </th> <th> white </th> <th> yellow </th> <th> sum </th>  </tr>
  <tr> <td align="right"> nonexpressed </td> <td> 70 (13%) </td> <td> 112 (21%) </td> <td> 354 (66%) </td> <td> 2 (0%) </td> <td> 538 (100%) </td> </tr>
  <tr> <td align="right"> expressed </td> <td> 3 (1%) </td> <td> 35 (13%) </td> <td> 236 (86%) </td> <td> 1 (0%) </td> <td> 275 (100%) </td> </tr>
   </table>

<pre><code class="r">write.table(comb, file=&quot;temp/microRNAwithstatus.txt&quot;,
            quote=FALSE, sep=&quot;\t&quot;, row.names=FALSE, col.names=TRUE, na=&quot;&quot;)

print( paste(&quot;Unique MI: &quot;, length(unique(comb$MI))))
</code></pre>

<p>[1] &ldquo;Unique MI:  794&rdquo;</p>

<pre><code class="r"># comb = data.frame(uniqueID=unfilteredcommonMIMAT)
# comb$lookupID = unlist(lapply(unfilteredcommonMIMAT, FUN=function(x)strsplit(x, &quot;_&quot;)[[1]][1]))
# comb$status = curatedtab[match(comb$lookupID, curatedtab$MIMAT), &quot;status&quot;]
# comb$name = curatedtab[match(comb$lookupID, curatedtab$MIMAT), &quot;miRNA&quot;]
# comb$AHUS = &quot;unknown&quot;
# comb$AHUS[(comb$uniqueID %in% unfilteredAHUSMIMAT)]=&quot;notexpressed&quot;
# comb$AHUS[(comb$uniqueID %in% filteredAHUSMIMAT)]=&quot;expressed&quot;
# comb$UCAM = &quot;unknown&quot;
# comb$UCAM[(comb$uniqueID %in% unfilteredUCAMMIMAT)]=&quot;notexpressed&quot;
# comb$UCAM[(comb$uniqueID %in% filteredUCAMMIMAT)]=&quot;expressed&quot;
# comb=comb[!is.na(comb$status),]
#table(comb[comb$status==&quot;purple&quot;, c(&quot;AHUS&quot;, &quot;UCAM&quot;)])
</code></pre>

<p>The two data sets differ quite a bit in what types of microRNA that are filtered out. It might be an error somewhere in the counting, but I was unable to find it. From the numbers it is also clear that the filtering of the two data sets differ. More microRNAs are lost in the AHUS filtering, and this might explain the loss of almost all the purples.</p>

<h2>References</h2>

<p>The shaping and functional consequences of the microRNA landscape in breast cancer.
Dvinge H, Git A, Gräf S, Salmon-Divon M, Curtis C, Sottoriva A, Zhao Y, Hirst M, Armisen J, Miska EA, Chin SF, Provenzano E, Turashvili G, Green A, Ellis I, Aparicio S, Caldas C.
Nature. 2013 May 16;497(7449):378-82. doi: 10.1038/nature12108. Epub 2013 May 5.</p>

<p>R Core Team (2013). R: A language and environment for statistical computing. R Foundation for Statistical Computing,
  Vienna, Austria. URL <a href="http://www.R-project.org/">http://www.R-project.org/</a></p>

<p>Yihui Xie (2013). knitr: A general-purpose package for dynamic report generation in R. R package version 1.5.</p>

<p>Yihui Xie (2013) Dynamic Documents with R and knitr. Chapman and Hall/CRC. ISBN 978-1482203530</p>

<p>Yihui Xie (2013) knitr: A Comprehensive Tool for Reproducible Research in R. In Victoria Stodden, Friedrich Leisch and
  Roger D. Peng, editors, Implementing Reproducible Computational Research. Chapman and Hall/CRC. ISBN 978-1466561595</p>

<p>RStudio Team (2012). RStudio: Integrated Development for R. RStudio, Inc., Boston, MA URL <a href="http://www.rstudio.com/">http://www.rstudio.com/</a>.</p>

<pre><code class="r">sessionInfo()
</code></pre>

<pre><code>R version 3.1.1 (2014-07-10)
Platform: x86_64-apple-darwin10.8.0 (64-bit)

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] grid      parallel  stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] MAMA_2.2.1            GeneMeta_1.36.0       gtools_3.4.1         
 [4] multtest_2.20.0       metaMA_2.1            SMVar_1.3.3          
 [7] genefilter_1.46.1     sva_3.10.0            mgcv_1.8-4           
[10] nlme_3.1-120          corpcor_1.6.7         xtable_1.7-4         
[13] RColorBrewer_1.1-2    knitr_1.9             data.table_1.9.2     
[16] plyr_1.8.1            AgiMicroRna_2.14.0    affycoretools_1.36.1 
[19] GO.db_2.14.0          RSQLite_1.0.0         DBI_0.3.1            
[22] AnnotationDbi_1.26.1  GenomeInfoDb_1.0.2    preprocessCore_1.26.1
[25] affy_1.42.3           limma_3.20.9          Biobase_2.24.0       
[28] BiocGenerics_0.10.0  

loaded via a namespace (and not attached):
 [1] acepack_1.3-3.3           affyio_1.32.0            
 [3] annaffy_1.36.0            annotate_1.42.1          
 [5] AnnotationForge_1.6.1     base64enc_0.1-2          
 [7] BatchJobs_1.5             BBmisc_1.9               
 [9] BiocInstaller_1.14.3      BiocParallel_0.6.1       
[11] biomaRt_2.20.0            Biostrings_2.32.1        
[13] biovizBase_1.12.3         bit_1.1-12               
[15] bitops_1.0-6              brew_1.0-6               
[17] BSgenome_1.32.0           Category_2.30.0          
[19] caTools_1.17.1            checkmate_1.5.1          
[21] cluster_2.0.1             codetools_0.2-10         
[23] colorspace_1.2-4          DESeq2_1.4.5             
[25] dichromat_2.0-0           digest_0.6.8             
[27] edgeR_3.6.8               evaluate_0.5.5           
[29] fail_1.2                  ff_2.2-13                
[31] foreach_1.4.2             foreign_0.8-63           
[33] formatR_1.0               Formula_1.2-0            
[35] gcrma_2.36.0              gdata_2.13.3             
[37] geneplotter_1.42.0        GenomicAlignments_1.0.6  
[39] GenomicFeatures_1.16.3    GenomicRanges_1.16.4     
[41] ggbio_1.12.10             ggplot2_1.0.0            
[43] GOstats_2.30.0            gplots_2.16.0            
[45] graph_1.42.0              gridExtra_0.9.1          
[47] GSEABase_1.26.0           gtable_0.1.2             
[49] Hmisc_3.15-0              hwriter_1.3.2            
[51] IRanges_1.22.10           iterators_1.0.7          
[53] KernSmooth_2.23-14        lattice_0.20-30          
[55] latticeExtra_0.6-26       locfit_1.5-9.1           
[57] markdown_0.7.4            MASS_7.3-39              
[59] Matrix_1.1-5              MergeMaid_2.36.0         
[61] metaArray_1.42.0          mime_0.2                 
[63] munsell_0.4.2             nnet_7.3-9               
[65] oligoClasses_1.26.0       PFAM.db_2.14.0           
[67] proto_0.3-10              R.methodsS3_1.7.0        
[69] R.oo_1.19.0               R.utils_1.34.0           
[71] R2HTML_2.3.1              RBGL_1.40.1              
[73] Rcpp_0.11.4               RcppArmadillo_0.4.650.1.1
[75] RCurl_1.95-4.5            ReportingTools_2.4.0     
[77] reshape2_1.4.1            rpart_4.1-9              
[79] Rsamtools_1.16.1          rtracklayer_1.24.2       
[81] scales_0.2.4              sendmailR_1.2-1          
[83] splines_3.1.1             stats4_3.1.1             
[85] stringr_0.6.2             survival_2.38-1          
[87] tools_3.1.1               VariantAnnotation_1.10.5 
[89] XML_3.98-1.1              XVector_0.4.0            
[91] zlibbioc_1.10.0          
</code></pre>

<p>generation ended 2015-05-18 15:58:28. Time spent 0 minutes .</p>

</body>

</html>
